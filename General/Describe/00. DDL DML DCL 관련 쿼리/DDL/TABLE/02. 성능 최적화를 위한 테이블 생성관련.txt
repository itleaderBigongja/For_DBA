*********************** [ 성능 최적화를 위한 테이블 설계 ] ***********************
대용량 데이터를 처리할 경우 파티셔닝(Partitioning)과 인덱스(Indexing)을 고려해야한다.

ㅇ 파티셔닝을 적용한 테이블 생성(RANGE PARTITION)
예제: 가입한 고객일 기준으로 데이터 분할

CREATE TABLE CUST_TABLE(
	CUST_NO			NUMBER(10)
	CUST_NM			VARCHAR2(30)	NOT NULL,
	EAMIL			VARCHAR2(30)	UNIQUE,
	PHONE_NUMBER	VARCHAR2(20)	UNIQUE,
	REG_DT			DATE			DEFAULT SYSDATE NOT NULL,
	POINT			NUMBER(10,2)	CHECK(POINT > 0),
	CONSTRAINT CUST_PARTITION_PK PRIMARY KEY (CUST_NO, REG_DT)
)
PARTITION BY RANGE(REG_DT) (
	PARTITION PT_202502 VALUES LESS THAN('202503'),		/* 202502 ~ 202503 인스턴스 */
	PARTITION PT_202503 VALUES LESS THAN('202504'),		/* 202503 ~ 202504 인스턴스 */
	PARTITION PT_202504 VALUES LESS THAN('202505'),		/* 202504 ~ 202505 인스턴스 */
	PARTITION PT_202505 VALUES LESS THAN('202506'),		/* 202505 ~ 202506 인스턴스 */
	PARTITION PT_202506 VALUES LESS THAN('202507')		/* 202506 ~ 202507 인스턴스 */
)TABLESPACE USERS
	PCTFREE 10
	PCTUSED 40
	STORAGE(
		INITIAL	1M
		NEXT	1M
		MAXEXTENTS UNLIMITED
	);
	
ㅇ 파티션 테이블 조회
SELECT * FROM CUST_TABLE PARTITION(PT_202502); /*REG_DT가 20250201 ~ 20250228까지 데이터 */

ㅇ 파티션 오래된 데이터만 제거
ALTER TABLE CUST_TABLE TRUNCATE PARTITION PT_202502;

ㅇ 특정 파티션 추가
ALTER TABLE CUST_TABLE ADD PARTITION PT_202505 VALUES LESS THAN('202506');

ㅇ 특정 파티션 삭제
ALTER TABLE CUST_TABLE DROP PARTITION PT_202505;

ㅇ 오래된 데이터 파티션 병합(MERGE)
ALTER TABLE CUST_TABLE MERGE PARTITIONS PT_202501, PT_202502 INTO PARTITION PT_LAST_DATE
설명: PT_202501과 PT_202502파티션을 PT_LAST_DATE로 병합
     기존 데이터를 유지하면서 파티션 수를 줄임 