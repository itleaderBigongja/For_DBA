/** 단일 테이블 클러스터링
 *  [ 단일 테이블 클러스터링이란? ]
 *  단일 테이블 클러스터링은 Heap Table과 다르게, 특정 컬럼을 기준으로 물리적으로 데이터를 묶어서
 *  저장하는 방식이다. 즉, 자주 함께 조회되는 데이터가 같은 블록(Block)이나 페이지(Page) 내에 저장되도록 최적화하는 기법이다.
 * 
 *  Heap Table과의 차이
 *   ㅇ Heap Table: 삽입 시, 빈 공간을 찾아 비순차적으로 저장 -> Random Access Block I/O 증가
 *   ㅇ 클러스터링 테이블: 특정 키(cluster key)를 기준으로 동일한 블록(Page)에 저장 -> 순차 I/O 최적화
 * 
 * 
 *  단일 테이블 클러스터링의 핵심 원리
 *   1. 클러스터링 키(Clustering Key)기반 저장
 *		ㅇ 특정 키(예: 고객 ID, 주문번호 등)을 기준으로 데이터가 인접한 블록에 배치됨
 *      ㅇ 동일한 키 값을 가진 데이터가 물리적으로 가까운 위치에 저장됨 -> 데이터 로컬리티(locality) 극대화
 * 		ㅇ 일반적으로 범위 조회(Range Scan), 다량의 데이터 검색이 빈번한 경우 최적
 * 
 *		예제 시나리오:
 *		고객 주문 데이터가 있을 때, customer_id를 클러스터링 키로 설정하면,
 * 		동일한 고객의 주문 데이터가 같은 블록 내에 배치되어 검색 속도가 최적화 됨.
 * 
 * 
 *   2. 클러스터링 저장 구조( 데이터 배치 방식 )
 *      ㅇ Heap Table은 페이지(Page) 내 가용 공간을 찾아 랜덤하게 저장되므로,
 *         동일한 customer_id를 가진 데이터가 여러 블록에 퍼질 가능성이 높음
 *      
 *      ㅇ 반면, 단일 테이블 클러스터링은 동일한 customer_id 데이터를 한 블록 내에 모음
 * 
 *      Heap Table 구조(랜덤 배치)
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 *      Block   | customer_id					 | order_id
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 *      1       | 1001							 | A001
 *      1       | 1005							 | A005
 *      2       | 1002						     | A002
 *      2       | 1001							 | A003
 *      3       | 1003							 | A004
 *      3       | 1005   						 | A006
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 * 
 * 		클러스터링 테이블 구조(Key 기반 배치)
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
 * 		Block   | customer_id					 | order_id
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ    		
 *		1		| 1001							 | A001
 *		1		| 1001							 | A003
 *	    2		| 1002							 | A002
 *		3		| 1003							 | A004
 *		4		| 1005							 | A005
 *		4		| 1005							 | A006
 * ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 *      체크 포인트: 동일한 고객의 데이터가 블록(Page)에 저장됨으로써 검색 성능이 최적화됨!
 * 
 * 
 *  3. 클러스터링 테이블의 장점과 단점
 *     장점:
 * 		 ㅇ 범위 검색(Range Scan) 성능 최적화 -> 인덱스 탐색 없이 Sequential I/O가 가능
 * 		 ㅇ Join 성능 향상 -> customer_id 같은 공통 키 기준으로 Join 시, 디스크 I/O 감소
 *       ㅇ 캐시 효율 증가 	-> 동일 블록(Page)내 데이터 접근이 많아 Buffer Cache Hit Ratio 증가
 *     
 *     단점:
 * 		 ㅇ INSERT / UPDATE 성능 저하 가능 -> 키 값에 따라 특정 블록이 과부하(Hot Block) 가능성이 있음
 *       ㅇ 재배치 비용 발생 -> 데이터가 삽입될 때 클러스터링을 유지하려면 재정렬이 필요
 * 
 * 
 *     ㅁ 단일 테이블 클러스터링 생성 방법
 *      -> 클러스터링 테이블을 만들려면 Oracle 기준으로 다음과 같이 생성할 수 있다.
 *       1. Cluster 생성
 * 			CREATE CLUSTER customer_orders_cluster (
 * 				customer_id			NUMBER(10)
 *          ) SIZE 1024;
 * 			체크 포인트: 클러스터를 생성하면서 customer_id를 기준으로 저장될 공간을 할당함
 *  
 * 		 2. 클러스터 인덱스 생성(선택 사항)
 *          CREATE INDEX IDX_CUSTOMER_ORDERS_CLUSTER
 * 				ON CLUSTER customer_orders_cluster;
 * 			체크 포인트: 클러스터 데이터 검색을 위한 인덱스를 추가로 생성 가능
 * 					  ( 클러스터링 테이블은 Primary Key 없이도 검색 최적화가 가능하지만, 인덱스가 추가되면 특정 쿼리 최적화에 도움이 됨)
 * 
 *          ㅁ 클러스터링 Key로 인덱스를 만드는 이유:
 * 			   [ I/O 효율성 향상 - 물리적 데이터 정렬 ] 
 * 				- 클러스터링 키 값에 따라 테이블의 데이터가 물리적으로 정렬된다.
 *   			  즉, 특정 클러스터 키 값을 가진 행들은 디스크 상에서 서로 가깝게 위치하게 된다.
 * 
 * 			   [ I/O 효율성 향상 - 범위 스캔 최적화 ] : 
 * 				- 클러스터링 키를 기준으로 범위 스캔(range scan)을 수행할 때, 디스크에서 읽어야 하는 데이터 블록의 수를
 *     			  크게 줄일 수 있다. 예를 들어, 날짜별로 클러스터링된 테이블에서 특정 기간의 데이터를 조회할 때 매우 효율적이다.
 * 			
 * 			   [ I/O 효율성 향상 - 연관 데이터 동시 접근 ]
 * 			   클러스터링된 테이블 간의 조인(Join)연산 시 에도 효율성이 증가한다.
 *  		   조인 조건 컬럼이 클러스터 키인 경우, 관련 데이터가 물리적으로 함께 저장되어 있어 I/O 비용이 절감된다.
 * 		  
 * 
 *			   [ 공간 효율성(Heap 테이블) ] 
 *			   클러스터의 인덱스는 B-Tree 인덱스의 리프노드에 실제 데이터 ROW가 들어가기 때문에 테이블의
 *			   저장 공간 효율성이 높아진다. 힙 테이블에서는 인덱스가 ROWID를 통해 데이터에 접근해야 하지만,
 *			   클러스터 인덱스에서는 인덱스 자체에 데이터가 포함되어 있으므로 중복 저장을 피할수 있다.
 *
 *			   
 *             [ 쿼리 성능 최적화 - 전체 테이블 스캔 최소화 ] 
 * 			   클러스터링 키 인덱스를 사용하면 전체 테이블 스캔(full table scan)의 필요성을
 *			   줄일 수 있다. 필요한 데이터만 빠르게 찾아서 접근할 수 있기 때문이다.
 *
 *			   [ 쿼리 성능 최적화 - 인덱스 전용 테이블 ] 
 *			   클러스터는 테이블을 구성하는 방법 중 하나로 클러스터 테이블은 
 *   		   클러스터 인덱스 없이 테이블 구성이 불가능하다.
 * 			
 * 		       [ 쿼리 성능 최적화 - 쿼리 응답 시간 단축 ] 
 * 			   I/O 감소와 효율적인 데이터 접근은 쿼리 응답 시간 단축으로 이어진다.
 * 				
 * 
 * 			   [ 논리적 데이터 그룹화 - 데이터 모델링 지원 ]
 * 			   클러스터링은 데이터 모델링 관점에서 관련 데이터를 논리적으로 그룹화하는데 도움을 준다.
 * 			   예를 들어, 주문 테이블과 주문 상세 테이블을 클러스터링하여 주문 관련 데이터를 함께 관리할 수 있다.
 *				
 *			   [ 논리적 데이터 그룹화 - 유지보수 편의성 ] 
 * 			   관련 데이터가 함게 저장되므로, 데이터 백업, 복구, 재구성 들의 유지보수 작업이
 * 			   더 효율적으로 수행될 수 있다.
 *				
 *
 *		
 *		3. 테이블 생성 순서 ( 클러스터링 테이블은 인덱스가 없으면 조회를 할수 없다. 반드시 인덱스가 필요하다. )
 *			
 *			1. 클러스터 생성
 *			CREATE CLUSTER customer_orders_cluster (
 *   			customer_id NUMBER(10)
 *			) SIZE 1024;
 *
 *			2. 클러스터링 테이블 생성
 *			CREATE TABLE customer_orders (
 *   			customer_id NUMBER(10),
 *    			order_id VARCHAR2(20),
 *  			order_date DATE
 *			) CLUSTER customer_orders_cluster (customer_id);
 *
 *			3. 클러스터를 사용(조회)하기 위해서는 인덱스가 필요하다.
 *			CREATE INDEX idx_customer_orders_cluster 
 *			ON CLUSTER customer_orders_cluster;
 *
 *			4. 클러스터링 테이블 조회
 *			SELECT * FROM customer_orders;
 *
 *
 *      4. 데이터 삽입
 *      	INSERT INTO customer_orders VALUES (1001, 'A001', SYSDATE);
 * 			INSERT INTO customer_orders VALUES (1001, 'A003', SYSDATE);
 * 			INSERT INTO customer_orders VALUES (1002, 'A002', SYSDATE);
 * 			INSERT INTO customer_orders VALUES (1003, 'A004', SYSDATE);
 * 			INSERT INTO customer_orders VALUES (1005, 'A005', SYSDATE);
 * 			INSERT INTO customer_orders VALUES (1005, 'A006', SYSDATE);
 *          
 * 			체크 포인트: customer_id가 동일한 데이티ㅓ는 같은 블록(Page)에 저장됨
 * 					  customer_id를 기준으로 검색할 때 Random Block I/O 없이 Sequential Block I/O가 발생
 * 
 * 
 * 	    5. 단일 테이블 클러스터링이 적합한 경우
 * 		 ㅇ 같은 키(예: customer_id 또는 product_id)를 기준으로 자주 검색되는 데이터
 * 		 ㅇ 범위 검색(Range Scan)이 많은 경우(날짜, 고객별 트랜잭션 분석 등)
 * 		 ㅇ 캠시 활용을 극대화하고 싶은 경우(동일 블록 내에서 자주 조회)
 * 
 * 		   단일 테이블 클러스터링이 적합하지 않은 경우
 * 		 ㅇ 랜덤 INSERT / UPDATE / DELETE가 많아 블록 핫스팟(Hot Block)발생 가능성이 큰 경우
 * 		 ㅇ 트랜잭션 성격이 강한 OLTP 환경( INSERT 속도가 중요한 경우 )
 * 		 ㅇ 클러스터링 키가 고유한 값(UUID 등)일 경우 -> 클러스터링 효과 없음
 * 
 *      6. 결론: 단일 테이블 클러스터링 정리
 * 				ㅇ Heap Table은 데이터가 삽입될 때, 비순차적으로 저장된다.
 * 				ㅇ 단일 테이블 클러스터링은 특정 키(Clustering Key)를 기준으로 데이터가 동일 블록에 저장됨.
 * 				ㅇ 검색 기능(특히 Range Scan, Join)이 크게 향상되며, I/O 효율 최적화 기능
 * 				ㅇ INSERT / UPDATE 성능 저하 가능성이 있으므로, OLTP 환경에서는 신중히 적용 필요
 **/     		